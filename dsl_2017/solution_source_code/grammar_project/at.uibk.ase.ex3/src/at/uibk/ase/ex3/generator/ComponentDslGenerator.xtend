/*
 * generated by Xtext 2.11.0
 */
package at.uibk.ase.ex3.generator

import at.uibk.ase.ex3.componentDsl.AttributeType
import at.uibk.ase.ex3.componentDsl.BasicType
import at.uibk.ase.ex3.componentDsl.Entity
import at.uibk.ase.ex3.componentDsl.EntityType
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import at.uibk.ase.ex3.componentDsl.EntityBaseTypeEnum
import java.util.List
import java.util.Collections
import at.uibk.ase.ex3.componentDsl.Add
import at.uibk.ase.ex3.componentDsl.Attribute
import at.uibk.ase.ex3.componentDsl.Create

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ComponentDslGenerator extends AbstractGenerator {
	val entitiesPackageName = "at.uibk.ase.ex3.transformation.entities"

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val allEntities = resource.allContents.toIterable.filter(Entity).toList
		
		//generate entities
		for (e : allEntities) {
			fsa.generateFile("entities/" + e.name + ".java", e.compile)
		}
		for(i : EntityBaseTypeEnum.values){
			fsa.generateFile("entities/" + i + ".java", i.compile)
		}

		//generate actions
		val serviceClassName = "Service";
		fsa.generateFile("actions/"+ serviceClassName+".java", generateService(resource, allEntities))
		
		//test actions
		fsa.generateFile("entities/tests/ComponentTest.java", generateComponentTest(resource, serviceClassName, allEntities))
		fsa.generateFile("actions/tests/ServiceTest.java", generateServiceTest(resource, serviceClassName, allEntities))
	}
	
	def compile(EntityBaseTypeEnum type){
		'''
		//generated
		package «entitiesPackageName»;
		
		public interface «type»{
		}
		'''
	}
	
	def getEntitiesByType(EntityBaseTypeEnum type, List<Entity> entities){
		val List<Entity> foundEntities = newArrayList
		for (e: entities){
			if (e.parent == type){
				Collections::addAll(foundEntities, e)
			}
		}
		return foundEntities
	}
	
	def getAddActions(Resource resource){
		val List<Add> foundActions = newArrayList
		for (c : resource.allContents.toIterable){
			if (c instanceof Add){
				Collections::addAll(foundActions, c)
			}
		}
		return foundActions
	}
	
	def getCreateActions(Resource resource){
		val List<Create> foundActions = newArrayList
		for (c : resource.allContents.toIterable){
			if (c instanceof Create){
				println(c)
				Collections::addAll(foundActions, c)
			}
		}
		return foundActions
	}
	
	/**
	 * for each action supported by the grammar create a corresponding method
	 */
	def generateService(Resource resource, List<Entity> entities) {
		'''
		//generated
		package at.uibk.ase.ex3.transformation.actions;
		
		import java.util.List;
		«FOR entity : entities»
		import «entitiesPackageName».«entity.name»;
		«ENDFOR»
		
		public class Service{
			
			«FOR entity : entities»
			public «entity.name» create«entity.name»(«entity.attributes.get(0).type.compile» «entity.attributes.get(0).name», «entity.attributes.get(0).type.compile» «entity.attributes.get(1).name»){
				return new «entity.name»(«entity.attributes.get(0).name», «entity.attributes.get(1).name»);
			}
			
			«ENDFOR»
			«FOR g:getEntitiesByType(EntityBaseTypeEnum.GROUP, entities)»
			«FOR m:getEntitiesByType(EntityBaseTypeEnum.MEMBER, entities)»
			public void add«EntityBaseTypeEnum.MEMBER»To«EntityBaseTypeEnum.GROUP»(«m.name» member, «g.name» group){
				group.add(member);
			}
			«ENDFOR»
			«ENDFOR»
			
			«FOR entity : entities»
			«IF entity.parent == EntityBaseTypeEnum.GROUP»
			«val Attribute a = getArrayAttribute(entity)»
			public List<«a.type.elementType.typeToString»> getOrder(«entity.name» c){
				throw new UnsupportedOperationException("Not implemented!");
			}
			«ENDIF»
			«ENDFOR»
			
			private boolean isRightDependency(Project p1, Project p2){
				for (Project p : p1.getDependencies()){
					if(p.getName().equals(p2.getName()) && p.getVersion().equals(p2.getVersion())){
						return true;
					}
				}
				return false;
			}
			
			private boolean isLeftDependency(Project p1, Project p2){
				for (Project p : p2.getDependencies()){
					if(p.getName().equals(p1.getName()) && p.getVersion().equals(p1.getVersion())){
						return true;
					}
				}
				return false;
			}
			
			«FOR entity : entities»
			«IF entity.parent == EntityBaseTypeEnum.GROUP»
			public boolean hasCycles(«entity.name» c1, «entity.name» c2){
				boolean right = false;
				boolean left = false;
				
				for (Project p1 : c1.getProjects()){
					for (Project p2 : c2.getProjects()){
						right = right || isRightDependency(p1, p2);
						left = left || isLeftDependency(p1, p2);
					}
				}
						
				return right && left;
			}
			«ENDIF»
			«ENDFOR»
		}
		'''
	}
		
	def getArrayAttribute(Entity entity){
		for (attribute : entity.attributes){
			if (attribute.type.array){
				return attribute;
			}
		}
	}
	
	def compile(Entity entity){
	'''
		//generated
		package «entitiesPackageName»;
		
		import java.util.List;
		import java.util.ArrayList;
		import «entitiesPackageName».«entity.parent»;
		
		public class «entity.name» «IF entity.parent !== null»implements «entity.parent»«ENDIF»{
			«FOR attribute : entity.attributes»
			private «attribute.type.compile» «attribute.name»;
			«ENDFOR»
			
			//constructor
			public «entity.name»(«entity.attributes.get(0).type.compile» «entity.attributes.get(0).name», «entity.attributes.get(0).type.compile» «entity.attributes.get(1).name»){
				this.«entity.attributes.get(0).name» = «entity.attributes.get(0).name»;
				this.«entity.attributes.get(1).name»=«entity.attributes.get(1).name»;
			}
			«IF entity.parent == EntityBaseTypeEnum.GROUP»
			«FOR attribute : entity.attributes»
			«IF attribute.type.array»
			
			//methods
			public void add(«attribute.type.elementType.typeToString» element){
				get«attribute.name.toFirstUpper»().add(element);
			}
			«ENDIF»
			«ENDFOR»
			«ENDIF»
			
			«IF entity.parent == EntityBaseTypeEnum.GROUP»
			«val Attribute a = getArrayAttribute(entity)»
			«IF a !== null»
			public int getSize(){
				if («a.name» == null){
					return 0;
				}
				return «a.name».size();
			}
			«ENDIF»
			«ENDIF»
			«IF entity.parent == EntityBaseTypeEnum.MEMBER»
			«val Attribute a = getArrayAttribute(entity)»
			«IF a !== null»
			//methods
			public void addDependency(«a.type.elementType.typeToString» element){
				get«a.name.toFirstUpper»().add(element);
			}
			«ENDIF»
			«ENDIF»
			
			//getters and setters
			«FOR attribute : entity.attributes»
			public «attribute.type.compile» get«attribute.name.toFirstUpper»(){
				«IF attribute.type.array»
				if («attribute.name» == null){
					«attribute.name» = new ArrayList<«attribute.type.elementType.typeToString»>();
				}
				«ENDIF»
				return «attribute.name»;
			}
			
			public void set«attribute.name.toFirstUpper»(«attribute.type.compile» _arg) {
				this.«attribute.name» = _arg;
			}
			«ENDFOR»
		}
	'''
	}
	
	def compile(AttributeType attributeType){
		if (attributeType.array) "List<"+attributeType.elementType.typeToString+">"
		else attributeType.elementType.typeToString
	}
	
	def dispatch typeToString(BasicType type){
		if (type.typeName == "string") "String"
		else type.typeName
	}
	
	def dispatch typeToString(EntityType type){
		type.entity.name
	}
	
	def generateComponentTest(Resource resource, String serviceClassName, List<Entity> entities) {
		'''
		//generated
		package at.uibk.ase.ex3.transformation.actions;
		
		import static org.junit.Assert.*;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import org.junit.Before;
		import org.junit.Test;
		
		«FOR entity : entities»
		import «entitiesPackageName».«entity.name»;
		«ENDFOR»
		
		public class ComponentTest {
			private «serviceClassName» service = new «serviceClassName»();
			private List<Component> components = new ArrayList<>();
				
				@Before
				public void setup(){
									
					//FIXME create action is not like the rest actions; extracting entity types not possible
					
					Component c1 = service.createComponent("component1", "1.0.0");
					Component c2 = service.createComponent("component2", "2.0.0");
					
					Project p1 = service.createProject("project1", "1.9.0");
					Project p2 = service.createProject("project2", "1.0.0");
					
					c1.add(p1);
					c1.add(p2);
					
					components.add(c1);
					components.add(c2);
					
				}
				
				@Test
				public void testSize(){
					assertEquals(2, components.get(0).getSize());
					assertEquals(0, components.get(1).getSize());
				}
			
		}
		'''
	}
	
		
	def generateServiceTest(Resource resource, String serviceClassName, List<Entity> entities) {
		'''
		//generated
		package at.uibk.ase.ex3.transformation.actions;
		
		import static org.junit.Assert.*;
		import java.util.List;
		
		import org.junit.Test;
		
		«FOR entity : entities»
		import «entitiesPackageName».«entity.name»;
		«ENDFOR»
		
		public class «serviceClassName»Test {
			private «serviceClassName» service = new «serviceClassName»();
			
			@Test
			public void testCreate(){
				String name = "component1";
				String version = "1.0.0";
				Component c = service.createComponent(name, version);
				
				assertEquals(name, c.getName());
				assertEquals(version, c.getVersion());
			}
		
			//FIXME take created components and check cycle dependencies
			@Test
			public void testCycleValid(){
				Component c1 = service.createComponent("component1", "1.0.0");
				Component c2 = service.createComponent("component2", "2.0.0");
			
				Project p1 = service.createProject("project1", "1.9.0");
				Project p2 = service.createProject("project2", "1.0.0");
			
				c1.add(p1);
				c1.add(p2);
			
				assertFalse(service.hasCycles(c1, c2));
			}
		
			//FIXME take created components and check cycle dependencies
			@Test
			public void testCycleInvalid(){
				Component c1 = service.createComponent("component1", "1.0.0");
				Component c2 = service.createComponent("component2", "2.0.0");
			
				Project p1 = service.createProject("project1", "1.9.0");
				Project p2 = service.createProject("project2", "1.0.0");
				Project p4 = service.createProject("project4", "1.9.0");
			
				p2.addDependency(p1);
				p4.addDependency(p2);
			
				c1.add(p1);
				c1.add(p4);
				c2.add(p2);
			
				assertTrue(service.hasCycles(c1, c2));
			}
		
			@Test
			public void testOrder(){
				//FIXME get created entities
				«val projects = newArrayList("project1","project2")»
				«val c1 = "c1"»
				«val cName = "component1"»
				«val cValue = "1.0.0"»
				Component «c1» = service.createComponent("«cName»", "«cValue»");
				Project p1 = service.createProject("project1", "1.9.0");
				Project p2 = service.createProject("project2", "1.0.0");
				//END FIXME
				
				«val addActions = getAddActions(resource)»
				«FOR a: addActions»
				«IF a.destinationName.equals(cName)»
				«FOR p : projects»
				«c1».add(p«projects.indexOf(p)+1»);
				«ENDFOR»
				«ENDIF»
				«ENDFOR»
				
				p2.addDependency(p1);
			
				List<Project> projects = service.getOrder(«c1»);
				assertEquals("«projects.get(0)»", projects.get(0).getName());
				assertEquals("«projects.get(1)»", projects.get(1).getName());
			}
		
			@Test(expected = Exception.class)
			public void testOrderEmpty(){
				service.getOrder(service.createComponent("component2", "2.0.0"));
			}
		}
		'''
	}
}
