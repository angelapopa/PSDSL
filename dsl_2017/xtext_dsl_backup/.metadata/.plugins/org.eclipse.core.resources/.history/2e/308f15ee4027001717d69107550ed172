/*
 * generated by Xtext 2.11.0
 */
package at.uibk.ase.ex3.validation

import at.uibk.ase.ex3.componentDsl.Add
import at.uibk.ase.ex3.componentDsl.AddDependency
import at.uibk.ase.ex3.componentDsl.ComponentDslPackage
import at.uibk.ase.ex3.componentDsl.EntityType
import at.uibk.ase.ex3.componentDsl.Group
import at.uibk.ase.ex3.componentDsl.Member
import java.util.ArrayList
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import java.util.List

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ComponentDslValidator extends AbstractComponentDslValidator {
	
	public static val COMPONENT = 'component'
	public static val INVALID_NAME = 'invalidDependency'
	public static val INVALID_DEPENDENCY_MSG = 'Invalid dependency assignment. Only dependencies between members can be defined.'
	public static val INVALID_ASSIGNMENT_SOURCE_MSG = 'Invalid assignment. Only members can be assigned.'
	public static val INVALID_ASSIGNMENT_DEST_MSG = 'Invalid assignment.'
	
	public static val INVALID_ASSIGNMENT_NON_EXISTING_MEMBER_NAME = "A member with this name was not yet created."
	public static val INVALID_ASSIGNMENT_NON_EXISTING_MEMBER_VERSION = "A member with this version was not yet created."
	public static val INVALID_ASSIGNMENT_NON_EXISTING_GROUP_NAME = "A group with this name was not yet created."
	public static val INVALID_ASSIGNMENT_NON_EXISTING_GROUP_VERSION = "A group with this version was not yet created."

	public static val INVALID_ASSIGNMENT_EXISTING_MEMBER_NAME = "A member with the same name exists already in this group."

	@Check
	def checkDependencyAssignmentSource(AddDependency addDependency) {
		if (addDependency.source.entity.parent instanceof Group) {
			error(INVALID_DEPENDENCY_MSG, ComponentDslPackage.eINSTANCE.addDependency_Source, INVALID_NAME)
		}
	}
	
	@Check
	def checkDependencyAssignmentDestination(AddDependency addDependency) {
		if (addDependency.dest.entity.parent instanceof Group) {
			error(INVALID_DEPENDENCY_MSG, ComponentDslPackage.eINSTANCE.addDependency_Dest, INVALID_NAME)
		}
	}
	
	@Check
	def checkAssignmentSourceType(Add addAction) {
		if (addAction.source.entity.parent instanceof Group){
			error(INVALID_ASSIGNMENT_SOURCE_MSG, ComponentDslPackage.eINSTANCE.add_Source, INVALID_NAME)
		}
	}
	
	@Check
	def checkAssignmentDestType(Add addAction) {
		if (addAction.dest.entity.parent instanceof Member){
			error(INVALID_ASSIGNMENT_DEST_MSG, ComponentDslPackage.eINSTANCE.add_Dest, INVALID_NAME)
		}
	}
	
	def getAllProjects(List<Object> candidates){
		val projects = new ArrayList<EntityType>();
		for (c : candidates){
			if (c instanceof EntityType){
				val proj =  c as EntityType
				if (proj.entity.parent instanceof Member && proj.name !== null){
					projects.add(c)
				}
			}
		}
		return projects;
	}
	
	def getAllComponents(List<Object> candidates){
		val components = new ArrayList<EntityType>();
		for (c : candidates){
			if (c instanceof EntityType){
				val proj =  c as EntityType
				if (proj.entity.parent instanceof Group && proj.name !== null){
					print(c)
					components.add(c)
				}
			}
		}
		return components;
	}
	
	def validateExistingProjects(Add addAction, List<Object> candidates){
		var foundEntity = false
		var foundVersion = false
		val projects = getAllProjects(candidates);
		
		for (p:projects){
			if (addAction.sourceName == p.name){
				foundEntity = true;
			}
			if (addAction.sourceVersion == p.version){
				foundVersion = true;
			}
		}
		
		if (!foundEntity){
			error(INVALID_ASSIGNMENT_NON_EXISTING_MEMBER_NAME, ComponentDslPackage.eINSTANCE.add_SourceName, INVALID_NAME)
		}
		if (!foundVersion){
			error(INVALID_ASSIGNMENT_NON_EXISTING_MEMBER_VERSION, ComponentDslPackage.eINSTANCE.add_SourceVersion, INVALID_NAME)
		}
	}
	
	def validateExistingComponents(Add addAction, List<Object> candidates){
		var foundEntity = false
		var foundVersion = false
		val components = getAllComponents(candidates);
		
		for (c:components){
			if (addAction.destinationName == c.name){
				foundEntity = true;
			}
			if (addAction.destinationVersion == c.version){
				foundVersion = true;
			}
		}
		
		if (!foundEntity){
			error(INVALID_ASSIGNMENT_NON_EXISTING_GROUP_NAME, ComponentDslPackage.eINSTANCE.add_DestinationName, INVALID_NAME)
		}
		if (!foundVersion){
			error(INVALID_ASSIGNMENT_NON_EXISTING_GROUP_VERSION, ComponentDslPackage.eINSTANCE.add_DestinationVersion, INVALID_NAME)
		}
	}
	
	@Check
	def checkAddExistingMembersAndGroups(Add addAction) {
		val rootElement = EcoreUtil2.getRootContainer(addAction)
        val candidates = EcoreUtil2.getAllProperContents(rootElement, false)
        var allEntities = candidates.toList
		validateExistingProjects(addAction, allEntities)
		validateExistingComponents(addAction, allEntities)		
	}
	
	@Check
	def checkAssignmentMemberUniqueness(Add addAction){
		val rootElement = EcoreUtil2.getRootContainer(addAction)
		val addActions = EcoreUtil2.getAllContentsOfType(rootElement, Add)
		for (action : addActions){
			if (action.identityEquals(addAction)){
				if (action.destinationName.equalsIgnoreCase(addAction.destinationName)){
					if (action.sourceName.equalsIgnoreCase(addAction.sourceName)){
						error(INVALID_ASSIGNMENT_EXISTING_MEMBER_NAME, ComponentDslPackage.eINSTANCE.add_SourceName, INVALID_NAME)
					}	
				}
			}
		}
	}
	
	@Check
	def checkAssignmentSameVersionOfMembersInGroup(Add addAction){
		//projects that are added to a group should have same version
	}
}
