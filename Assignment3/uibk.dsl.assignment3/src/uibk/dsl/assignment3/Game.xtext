grammar uibk.dsl.assignment3.Game with org.eclipse.xtext.common.Terminals

generate game "http://www.dsl.uibk/assignment3/Game"

/* HOWTO implement a code generator for text-based adventure, a suggestion ...
 * Alternative 1
 * 1) for each Scene generate a Java-class printing its description and all its objects on construction
 * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
 * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
 * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
 * 		(a new one or "this", in case we stayed at the same scene)
 * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
 * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
 *
 * Alternative 2
 * 1) Write a game engine.
 * 2) The game engine interprets the DSL instances (either config or code to fill in the gaps) and creates 
 *    a new game from it when started. (Example interpreter: 
 *    https://eclipse.org/Xtext/documentation/208_tortoise.html)
 * 
 *  
 *
 * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
 * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
 * here that you find useful for your own adventure game definition.
 */

// the actual game
Adventure:
	('start' startScene = [Scene]) & // where to start
	('end' endScene = [Scene]) & // when it's over
	(ingredients += Ingredient*) // the adventure's game ingredients
;

// what the adventure is composed of
Ingredient:
	Scene | Object
;
	
// a scene bundles objects and contains steps to escape to a new scene
Scene:
	'scene' name = ID
	('objects' '(' objects += [Object] (',' objects += [Object])* ')')?
	'description' description = STRING
	('actions' '(' actions += Step (',' actions += Step)* ')')?
	'end'
;

// objects are registered with a scene, e.g. "key", "door", ...
Object:
	'object' name = (STRING | ID)
	'description' description = STRING
	'end'
;

Step:
	// a step to solve the adventure, e.g., "pick up key" or "use key with door"	
	action = Action targetObject = [Object] (preposition = Preposition otherObject = [Object])? 'if'
		(('valid' valid = STRING) & // some message if the action was valid
		('default' default = STRING)) // some (default) message for an action, e.g. "I can't do that"
		'then' scene = [Scene] // if the encountered action is valid, open a new scene, e.g., when going through a door
		// if you want to have multiple actions within a single scene you probably need further create internal state tracking within scenes
;

// arbitrary actions to be used in the game
// in case they are more complex (e.g., have more parameters) you might consider rewriting them to parser rules
enum Action:
	LOOK = 'look at' | PICK = 'pick up' | GOTO = 'goto' | USE = 'use' // | ...
;

// prepositions for actions
enum Preposition:
	WITH = 'with' | INTO = 'into' // | ...
;

