/*
 * generated by Xtext 2.12.0
 */
package uibk.dsl.assignment3.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GameGrammarAccess extends AbstractGrammarElementFinder {
	
	public class AdventureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Adventure");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cStartKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cStartSceneAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cStartSceneSceneCrossReference_0_1_0 = (CrossReference)cStartSceneAssignment_0_1.eContents().get(0);
		private final RuleCall cStartSceneSceneIDTerminalRuleCall_0_1_0_1 = (RuleCall)cStartSceneSceneCrossReference_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Keyword cEndKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cEndSceneAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cEndSceneSceneCrossReference_1_1_0 = (CrossReference)cEndSceneAssignment_1_1.eContents().get(0);
		private final RuleCall cEndSceneSceneIDTerminalRuleCall_1_1_0_1 = (RuleCall)cEndSceneSceneCrossReference_1_1_0.eContents().get(1);
		private final Assignment cIngredientsAssignment_2 = (Assignment)cUnorderedGroup.eContents().get(2);
		private final RuleCall cIngredientsIngredientParserRuleCall_2_0 = (RuleCall)cIngredientsAssignment_2.eContents().get(0);
		
		///* HOWTO implement a code generator for text-based adventure, a suggestion ...
		// * Alternative 1
		// * 1) for each Scene generate a Java-class printing its description and all its objects on construction
		// * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
		// * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
		// * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
		// * 		(a new one or "this", in case we stayed at the same scene)
		// * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
		// * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
		// *
		// * Alternative 2
		// * 1) Write a game engine.
		// * 2) The game engine interprets the DSL instances (either config or code to fill in the gaps) and creates 
		// *    a new game from it when started. (Example interpreter: 
		// *    https://eclipse.org/Xtext/documentation/208_tortoise.html)
		// * 
		// *  
		// *
		// * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
		// * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
		// * here that you find useful for your own adventure game definition.
		// */ // the actual game
		//Adventure:
		//	'start' startScene=[Scene] & 'end' endScene=[Scene] & ingredients+=Ingredient*;
		@Override public ParserRule getRule() { return rule; }
		
		//'start' startScene=[Scene] & 'end' endScene=[Scene] & ingredients+=Ingredient*
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//'start' startScene=[Scene]
		public Group getGroup_0() { return cGroup_0; }
		
		//'start'
		public Keyword getStartKeyword_0_0() { return cStartKeyword_0_0; }
		
		//startScene=[Scene]
		public Assignment getStartSceneAssignment_0_1() { return cStartSceneAssignment_0_1; }
		
		//[Scene]
		public CrossReference getStartSceneSceneCrossReference_0_1_0() { return cStartSceneSceneCrossReference_0_1_0; }
		
		//ID
		public RuleCall getStartSceneSceneIDTerminalRuleCall_0_1_0_1() { return cStartSceneSceneIDTerminalRuleCall_0_1_0_1; }
		
		//// where to start
		//'end' endScene=[Scene]
		public Group getGroup_1() { return cGroup_1; }
		
		//'end'
		public Keyword getEndKeyword_1_0() { return cEndKeyword_1_0; }
		
		//endScene=[Scene]
		public Assignment getEndSceneAssignment_1_1() { return cEndSceneAssignment_1_1; }
		
		//[Scene]
		public CrossReference getEndSceneSceneCrossReference_1_1_0() { return cEndSceneSceneCrossReference_1_1_0; }
		
		//ID
		public RuleCall getEndSceneSceneIDTerminalRuleCall_1_1_0_1() { return cEndSceneSceneIDTerminalRuleCall_1_1_0_1; }
		
		//// when it's over
		//ingredients+=Ingredient*
		public Assignment getIngredientsAssignment_2() { return cIngredientsAssignment_2; }
		
		//Ingredient
		public RuleCall getIngredientsIngredientParserRuleCall_2_0() { return cIngredientsIngredientParserRuleCall_2_0; }
	}
	public class IngredientElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Ingredient");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSceneParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// what the adventure is composed of
		//Ingredient:
		//	Scene | Object;
		@Override public ParserRule getRule() { return rule; }
		
		//Scene | Object
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Scene
		public RuleCall getSceneParserRuleCall_0() { return cSceneParserRuleCall_0; }
		
		//Object
		public RuleCall getObjectParserRuleCall_1() { return cObjectParserRuleCall_1; }
	}
	public class SceneElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Scene");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSceneKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cObjectsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cObjectsAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final CrossReference cObjectsObjectCrossReference_2_2_0 = (CrossReference)cObjectsAssignment_2_2.eContents().get(0);
		private final RuleCall cObjectsObjectIDTerminalRuleCall_2_2_0_1 = (RuleCall)cObjectsObjectCrossReference_2_2_0.eContents().get(1);
		private final Group cGroup_2_3 = (Group)cGroup_2.eContents().get(3);
		private final Keyword cCommaKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Assignment cObjectsAssignment_2_3_1 = (Assignment)cGroup_2_3.eContents().get(1);
		private final CrossReference cObjectsObjectCrossReference_2_3_1_0 = (CrossReference)cObjectsAssignment_2_3_1.eContents().get(0);
		private final RuleCall cObjectsObjectIDTerminalRuleCall_2_3_1_0_1 = (RuleCall)cObjectsObjectCrossReference_2_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Keyword cDescriptionKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cActionsKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cActionsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cActionsStepParserRuleCall_5_2_0 = (RuleCall)cActionsAssignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final Keyword cCommaKeyword_5_3_0 = (Keyword)cGroup_5_3.eContents().get(0);
		private final Assignment cActionsAssignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cActionsStepParserRuleCall_5_3_1_0 = (RuleCall)cActionsAssignment_5_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_4 = (Keyword)cGroup_5.eContents().get(4);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// a scene bundles objects and contains steps to escape to a new scene
		//Scene:
		//	'scene' name=ID ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
		//	'description' description=STRING ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'scene' name=ID ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')? 'description' description=STRING
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')? 'end'
		public Group getGroup() { return cGroup; }
		
		//'scene'
		public Keyword getSceneKeyword_0() { return cSceneKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'objects'
		public Keyword getObjectsKeyword_2_0() { return cObjectsKeyword_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_1() { return cLeftParenthesisKeyword_2_1; }
		
		//objects+=[Object]
		public Assignment getObjectsAssignment_2_2() { return cObjectsAssignment_2_2; }
		
		//[Object]
		public CrossReference getObjectsObjectCrossReference_2_2_0() { return cObjectsObjectCrossReference_2_2_0; }
		
		//ID
		public RuleCall getObjectsObjectIDTerminalRuleCall_2_2_0_1() { return cObjectsObjectIDTerminalRuleCall_2_2_0_1; }
		
		//(',' objects+=[Object])*
		public Group getGroup_2_3() { return cGroup_2_3; }
		
		//','
		public Keyword getCommaKeyword_2_3_0() { return cCommaKeyword_2_3_0; }
		
		//objects+=[Object]
		public Assignment getObjectsAssignment_2_3_1() { return cObjectsAssignment_2_3_1; }
		
		//[Object]
		public CrossReference getObjectsObjectCrossReference_2_3_1_0() { return cObjectsObjectCrossReference_2_3_1_0; }
		
		//ID
		public RuleCall getObjectsObjectIDTerminalRuleCall_2_3_1_0_1() { return cObjectsObjectIDTerminalRuleCall_2_3_1_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_4() { return cRightParenthesisKeyword_2_4; }
		
		//'description'
		public Keyword getDescriptionKeyword_3() { return cDescriptionKeyword_3; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_4_0() { return cDescriptionSTRINGTerminalRuleCall_4_0; }
		
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'actions'
		public Keyword getActionsKeyword_5_0() { return cActionsKeyword_5_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5_1() { return cLeftParenthesisKeyword_5_1; }
		
		//actions+=Step
		public Assignment getActionsAssignment_5_2() { return cActionsAssignment_5_2; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_5_2_0() { return cActionsStepParserRuleCall_5_2_0; }
		
		//(',' actions+=Step)*
		public Group getGroup_5_3() { return cGroup_5_3; }
		
		//','
		public Keyword getCommaKeyword_5_3_0() { return cCommaKeyword_5_3_0; }
		
		//actions+=Step
		public Assignment getActionsAssignment_5_3_1() { return cActionsAssignment_5_3_1; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_5_3_1_0() { return cActionsStepParserRuleCall_5_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5_4() { return cRightParenthesisKeyword_5_4; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Object");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cObjectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Keyword cDescriptionKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDescriptionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_3_0 = (RuleCall)cDescriptionAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// objects are registered with a scene, e.g. "key", "door", ...
		//Object:
		//	'object' name=(STRING | ID)
		//	'description' description=STRING
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'object' name=(STRING | ID) 'description' description=STRING 'end'
		public Group getGroup() { return cGroup; }
		
		//'object'
		public Keyword getObjectKeyword_0() { return cObjectKeyword_0; }
		
		//name=(STRING | ID)
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(STRING | ID)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_0() { return cNameSTRINGTerminalRuleCall_1_0_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_1() { return cNameIDTerminalRuleCall_1_0_1; }
		
		//'description'
		public Keyword getDescriptionKeyword_2() { return cDescriptionKeyword_2; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_3() { return cDescriptionAssignment_3; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_3_0() { return cDescriptionSTRINGTerminalRuleCall_3_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class StepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Step");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActionActionEnumRuleCall_0_0 = (RuleCall)cActionAssignment_0.eContents().get(0);
		private final Assignment cTargetObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTargetObjectObjectCrossReference_1_0 = (CrossReference)cTargetObjectAssignment_1.eContents().get(0);
		private final RuleCall cTargetObjectObjectIDTerminalRuleCall_1_0_1 = (RuleCall)cTargetObjectObjectCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cPrepositionAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cPrepositionPrepositionEnumRuleCall_2_0_0 = (RuleCall)cPrepositionAssignment_2_0.eContents().get(0);
		private final Assignment cOtherObjectAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cOtherObjectObjectCrossReference_2_1_0 = (CrossReference)cOtherObjectAssignment_2_1.eContents().get(0);
		private final RuleCall cOtherObjectObjectIDTerminalRuleCall_2_1_0_1 = (RuleCall)cOtherObjectObjectCrossReference_2_1_0.eContents().get(1);
		private final Keyword cIfKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final UnorderedGroup cUnorderedGroup_4 = (UnorderedGroup)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cUnorderedGroup_4.eContents().get(0);
		private final Keyword cValidKeyword_4_0_0 = (Keyword)cGroup_4_0.eContents().get(0);
		private final Assignment cValidAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final RuleCall cValidSTRINGTerminalRuleCall_4_0_1_0 = (RuleCall)cValidAssignment_4_0_1.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cUnorderedGroup_4.eContents().get(1);
		private final Keyword cDefaultKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cDefaultAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cDefaultSTRINGTerminalRuleCall_4_1_1_0 = (RuleCall)cDefaultAssignment_4_1_1.eContents().get(0);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cSceneAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final CrossReference cSceneSceneCrossReference_6_0 = (CrossReference)cSceneAssignment_6.eContents().get(0);
		private final RuleCall cSceneSceneIDTerminalRuleCall_6_0_1 = (RuleCall)cSceneSceneCrossReference_6_0.eContents().get(1);
		
		//Step:
		//	action=Action targetObject=[Object] (preposition=Preposition otherObject=[Object])? 'if' ('valid' valid=STRING &
		//	'default' default=STRING) // some (default) message for an action, e.g. "I can't do that"
		//	'then' scene=[Scene];
		@Override public ParserRule getRule() { return rule; }
		
		//// a step to solve the adventure, e.g., "pick up key" or "use key with door"	
		//action=Action targetObject=[Object] (preposition=Preposition otherObject=[Object])? 'if' ('valid' valid=STRING &
		//'default' default=STRING) // some (default) message for an action, e.g. "I can't do that"
		//'then' scene=[Scene]
		public Group getGroup() { return cGroup; }
		
		//// a step to solve the adventure, e.g., "pick up key" or "use key with door"	
		//action=Action
		public Assignment getActionAssignment_0() { return cActionAssignment_0; }
		
		//Action
		public RuleCall getActionActionEnumRuleCall_0_0() { return cActionActionEnumRuleCall_0_0; }
		
		//targetObject=[Object]
		public Assignment getTargetObjectAssignment_1() { return cTargetObjectAssignment_1; }
		
		//[Object]
		public CrossReference getTargetObjectObjectCrossReference_1_0() { return cTargetObjectObjectCrossReference_1_0; }
		
		//ID
		public RuleCall getTargetObjectObjectIDTerminalRuleCall_1_0_1() { return cTargetObjectObjectIDTerminalRuleCall_1_0_1; }
		
		//(preposition=Preposition otherObject=[Object])?
		public Group getGroup_2() { return cGroup_2; }
		
		//preposition=Preposition
		public Assignment getPrepositionAssignment_2_0() { return cPrepositionAssignment_2_0; }
		
		//Preposition
		public RuleCall getPrepositionPrepositionEnumRuleCall_2_0_0() { return cPrepositionPrepositionEnumRuleCall_2_0_0; }
		
		//otherObject=[Object]
		public Assignment getOtherObjectAssignment_2_1() { return cOtherObjectAssignment_2_1; }
		
		//[Object]
		public CrossReference getOtherObjectObjectCrossReference_2_1_0() { return cOtherObjectObjectCrossReference_2_1_0; }
		
		//ID
		public RuleCall getOtherObjectObjectIDTerminalRuleCall_2_1_0_1() { return cOtherObjectObjectIDTerminalRuleCall_2_1_0_1; }
		
		//'if'
		public Keyword getIfKeyword_3() { return cIfKeyword_3; }
		
		//'valid' valid=STRING & 'default' default=STRING
		public UnorderedGroup getUnorderedGroup_4() { return cUnorderedGroup_4; }
		
		//'valid' valid=STRING
		public Group getGroup_4_0() { return cGroup_4_0; }
		
		//'valid'
		public Keyword getValidKeyword_4_0_0() { return cValidKeyword_4_0_0; }
		
		//valid=STRING
		public Assignment getValidAssignment_4_0_1() { return cValidAssignment_4_0_1; }
		
		//STRING
		public RuleCall getValidSTRINGTerminalRuleCall_4_0_1_0() { return cValidSTRINGTerminalRuleCall_4_0_1_0; }
		
		//// some message if the action was valid
		//'default' default=STRING
		public Group getGroup_4_1() { return cGroup_4_1; }
		
		//'default'
		public Keyword getDefaultKeyword_4_1_0() { return cDefaultKeyword_4_1_0; }
		
		//default=STRING
		public Assignment getDefaultAssignment_4_1_1() { return cDefaultAssignment_4_1_1; }
		
		//STRING
		public RuleCall getDefaultSTRINGTerminalRuleCall_4_1_1_0() { return cDefaultSTRINGTerminalRuleCall_4_1_1_0; }
		
		//// some (default) message for an action, e.g. "I can't do that"
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//scene=[Scene]
		public Assignment getSceneAssignment_6() { return cSceneAssignment_6; }
		
		//[Scene]
		public CrossReference getSceneSceneCrossReference_6_0() { return cSceneSceneCrossReference_6_0; }
		
		//ID
		public RuleCall getSceneSceneIDTerminalRuleCall_6_0_1() { return cSceneSceneIDTerminalRuleCall_6_0_1; }
	}
	
	public class ActionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Action");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLOOKEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLOOKLookAtKeyword_0_0 = (Keyword)cLOOKEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPICKEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPICKPickUpKeyword_1_0 = (Keyword)cPICKEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGOTOEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGOTOGotoKeyword_2_0 = (Keyword)cGOTOEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUSEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUSEUseKeyword_3_0 = (Keyword)cUSEEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Action:
		//	LOOK='look at' | PICK='pick up' | GOTO='goto' | USE='use' // | ...
		//;
		public EnumRule getRule() { return rule; }
		
		//LOOK='look at' | PICK='pick up' | GOTO='goto' | USE='use'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LOOK='look at'
		public EnumLiteralDeclaration getLOOKEnumLiteralDeclaration_0() { return cLOOKEnumLiteralDeclaration_0; }
		
		//'look at'
		public Keyword getLOOKLookAtKeyword_0_0() { return cLOOKLookAtKeyword_0_0; }
		
		//PICK='pick up'
		public EnumLiteralDeclaration getPICKEnumLiteralDeclaration_1() { return cPICKEnumLiteralDeclaration_1; }
		
		//'pick up'
		public Keyword getPICKPickUpKeyword_1_0() { return cPICKPickUpKeyword_1_0; }
		
		//GOTO='goto'
		public EnumLiteralDeclaration getGOTOEnumLiteralDeclaration_2() { return cGOTOEnumLiteralDeclaration_2; }
		
		//'goto'
		public Keyword getGOTOGotoKeyword_2_0() { return cGOTOGotoKeyword_2_0; }
		
		//USE='use'
		public EnumLiteralDeclaration getUSEEnumLiteralDeclaration_3() { return cUSEEnumLiteralDeclaration_3; }
		
		//'use'
		public Keyword getUSEUseKeyword_3_0() { return cUSEUseKeyword_3_0; }
	}
	public class PrepositionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Preposition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cWITHEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cWITHWithKeyword_0_0 = (Keyword)cWITHEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cINTOEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cINTOIntoKeyword_1_0 = (Keyword)cINTOEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Preposition:
		//	WITH='with' | INTO='into' // | ...
		//;
		public EnumRule getRule() { return rule; }
		
		//WITH='with' | INTO='into'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//WITH='with'
		public EnumLiteralDeclaration getWITHEnumLiteralDeclaration_0() { return cWITHEnumLiteralDeclaration_0; }
		
		//'with'
		public Keyword getWITHWithKeyword_0_0() { return cWITHWithKeyword_0_0; }
		
		//INTO='into'
		public EnumLiteralDeclaration getINTOEnumLiteralDeclaration_1() { return cINTOEnumLiteralDeclaration_1; }
		
		//'into'
		public Keyword getINTOIntoKeyword_1_0() { return cINTOIntoKeyword_1_0; }
	}
	
	private final AdventureElements pAdventure;
	private final IngredientElements pIngredient;
	private final SceneElements pScene;
	private final ObjectElements pObject;
	private final StepElements pStep;
	private final ActionElements eAction;
	private final PrepositionElements ePreposition;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GameGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAdventure = new AdventureElements();
		this.pIngredient = new IngredientElements();
		this.pScene = new SceneElements();
		this.pObject = new ObjectElements();
		this.pStep = new StepElements();
		this.eAction = new ActionElements();
		this.ePreposition = new PrepositionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("uibk.dsl.assignment3.Game".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///* HOWTO implement a code generator for text-based adventure, a suggestion ...
	// * Alternative 1
	// * 1) for each Scene generate a Java-class printing its description and all its objects on construction
	// * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
	// * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
	// * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
	// * 		(a new one or "this", in case we stayed at the same scene)
	// * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
	// * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
	// *
	// * Alternative 2
	// * 1) Write a game engine.
	// * 2) The game engine interprets the DSL instances (either config or code to fill in the gaps) and creates 
	// *    a new game from it when started. (Example interpreter: 
	// *    https://eclipse.org/Xtext/documentation/208_tortoise.html)
	// * 
	// *  
	// *
	// * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
	// * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
	// * here that you find useful for your own adventure game definition.
	// */ // the actual game
	//Adventure:
	//	'start' startScene=[Scene] & 'end' endScene=[Scene] & ingredients+=Ingredient*;
	public AdventureElements getAdventureAccess() {
		return pAdventure;
	}
	
	public ParserRule getAdventureRule() {
		return getAdventureAccess().getRule();
	}
	
	//// what the adventure is composed of
	//Ingredient:
	//	Scene | Object;
	public IngredientElements getIngredientAccess() {
		return pIngredient;
	}
	
	public ParserRule getIngredientRule() {
		return getIngredientAccess().getRule();
	}
	
	//// a scene bundles objects and contains steps to escape to a new scene
	//Scene:
	//	'scene' name=ID ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
	//	'description' description=STRING ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
	//	'end';
	public SceneElements getSceneAccess() {
		return pScene;
	}
	
	public ParserRule getSceneRule() {
		return getSceneAccess().getRule();
	}
	
	//// objects are registered with a scene, e.g. "key", "door", ...
	//Object:
	//	'object' name=(STRING | ID)
	//	'description' description=STRING
	//	'end';
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	//Step:
	//	action=Action targetObject=[Object] (preposition=Preposition otherObject=[Object])? 'if' ('valid' valid=STRING &
	//	'default' default=STRING) // some (default) message for an action, e.g. "I can't do that"
	//	'then' scene=[Scene];
	public StepElements getStepAccess() {
		return pStep;
	}
	
	public ParserRule getStepRule() {
		return getStepAccess().getRule();
	}
	
	//enum Action:
	//	LOOK='look at' | PICK='pick up' | GOTO='goto' | USE='use' // | ...
	//;
	public ActionElements getActionAccess() {
		return eAction;
	}
	
	public EnumRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//enum Preposition:
	//	WITH='with' | INTO='into' // | ...
	//;
	public PrepositionElements getPrepositionAccess() {
		return ePreposition;
	}
	
	public EnumRule getPrepositionRule() {
		return getPrepositionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
