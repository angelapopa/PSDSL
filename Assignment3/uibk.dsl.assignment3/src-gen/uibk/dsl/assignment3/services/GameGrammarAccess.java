/*
 * generated by Xtext 2.12.0
 */
package uibk.dsl.assignment3.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GameGrammarAccess extends AbstractGrammarElementFinder {
	
	public class AdventureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Adventure");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cStartKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cStartSceneAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cStartSceneSceneCrossReference_0_1_0 = (CrossReference)cStartSceneAssignment_0_1.eContents().get(0);
		private final RuleCall cStartSceneSceneIDTerminalRuleCall_0_1_0_1 = (RuleCall)cStartSceneSceneCrossReference_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Keyword cEndKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cEndSceneAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cEndSceneSceneCrossReference_1_1_0 = (CrossReference)cEndSceneAssignment_1_1.eContents().get(0);
		private final RuleCall cEndSceneSceneIDTerminalRuleCall_1_1_0_1 = (RuleCall)cEndSceneSceneCrossReference_1_1_0.eContents().get(1);
		private final Assignment cIngredientsAssignment_2 = (Assignment)cUnorderedGroup.eContents().get(2);
		private final RuleCall cIngredientsIngredientParserRuleCall_2_0 = (RuleCall)cIngredientsAssignment_2.eContents().get(0);
		
		///* HOWTO implement a code generator for text-based adventure, a suggestion ...
		// * Alternative 1
		// * 1) for each Scene generate a Java-class printing its description and all its objects on construction
		// * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
		// * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
		// * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
		// * 		(a new one or "this", in case we stayed at the same scene)
		// * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
		// * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
		// *
		// * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
		// * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
		// * here that you find useful for your own adventure game definition.
		// */ // the actual game
		//Adventure:
		//	'start' startScene=[Scene] & 'end' endScene=[Scene] & ingredients+=Ingredient*;
		@Override public ParserRule getRule() { return rule; }
		
		//'start' startScene=[Scene] & 'end' endScene=[Scene] & ingredients+=Ingredient*
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//'start' startScene=[Scene]
		public Group getGroup_0() { return cGroup_0; }
		
		//'start'
		public Keyword getStartKeyword_0_0() { return cStartKeyword_0_0; }
		
		//startScene=[Scene]
		public Assignment getStartSceneAssignment_0_1() { return cStartSceneAssignment_0_1; }
		
		//[Scene]
		public CrossReference getStartSceneSceneCrossReference_0_1_0() { return cStartSceneSceneCrossReference_0_1_0; }
		
		//ID
		public RuleCall getStartSceneSceneIDTerminalRuleCall_0_1_0_1() { return cStartSceneSceneIDTerminalRuleCall_0_1_0_1; }
		
		//// where to start
		//'end' endScene=[Scene]
		public Group getGroup_1() { return cGroup_1; }
		
		//'end'
		public Keyword getEndKeyword_1_0() { return cEndKeyword_1_0; }
		
		//endScene=[Scene]
		public Assignment getEndSceneAssignment_1_1() { return cEndSceneAssignment_1_1; }
		
		//[Scene]
		public CrossReference getEndSceneSceneCrossReference_1_1_0() { return cEndSceneSceneCrossReference_1_1_0; }
		
		//ID
		public RuleCall getEndSceneSceneIDTerminalRuleCall_1_1_0_1() { return cEndSceneSceneIDTerminalRuleCall_1_1_0_1; }
		
		//// when it's over
		//ingredients+=Ingredient*
		public Assignment getIngredientsAssignment_2() { return cIngredientsAssignment_2; }
		
		//Ingredient
		public RuleCall getIngredientsIngredientParserRuleCall_2_0() { return cIngredientsIngredientParserRuleCall_2_0; }
	}
	public class IngredientElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Ingredient");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSceneParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHeroParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// what the adventure is composed of
		//Ingredient:
		//	Scene | Object | Hero;
		@Override public ParserRule getRule() { return rule; }
		
		//Scene | Object | Hero
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Scene
		public RuleCall getSceneParserRuleCall_0() { return cSceneParserRuleCall_0; }
		
		//Object
		public RuleCall getObjectParserRuleCall_1() { return cObjectParserRuleCall_1; }
		
		//Hero
		public RuleCall getHeroParserRuleCall_2() { return cHeroParserRuleCall_2; }
	}
	public class HeroElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Hero");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNameKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cHPKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cHealthPointsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cHealthPointsSTRINGTerminalRuleCall_3_0 = (RuleCall)cHealthPointsAssignment_3.eContents().get(0);
		
		//Hero:
		//	'name' name=ID
		//	'HP' healthPoints=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'name' name=ID 'HP' healthPoints=STRING
		public Group getGroup() { return cGroup; }
		
		//'name'
		public Keyword getNameKeyword_0() { return cNameKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'HP'
		public Keyword getHPKeyword_2() { return cHPKeyword_2; }
		
		//healthPoints=STRING
		public Assignment getHealthPointsAssignment_3() { return cHealthPointsAssignment_3; }
		
		//STRING
		public RuleCall getHealthPointsSTRINGTerminalRuleCall_3_0() { return cHealthPointsSTRINGTerminalRuleCall_3_0; }
	}
	public class SceneElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Scene");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSceneKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cObjectsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cObjectsAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final CrossReference cObjectsObjectCrossReference_2_2_0 = (CrossReference)cObjectsAssignment_2_2.eContents().get(0);
		private final RuleCall cObjectsObjectIDTerminalRuleCall_2_2_0_1 = (RuleCall)cObjectsObjectCrossReference_2_2_0.eContents().get(1);
		private final Group cGroup_2_3 = (Group)cGroup_2.eContents().get(3);
		private final Keyword cCommaKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Assignment cObjectsAssignment_2_3_1 = (Assignment)cGroup_2_3.eContents().get(1);
		private final CrossReference cObjectsObjectCrossReference_2_3_1_0 = (CrossReference)cObjectsAssignment_2_3_1.eContents().get(0);
		private final RuleCall cObjectsObjectIDTerminalRuleCall_2_3_1_0_1 = (RuleCall)cObjectsObjectCrossReference_2_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Keyword cDescriptionKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cActionsKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cActionsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cActionsStepParserRuleCall_5_2_0 = (RuleCall)cActionsAssignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final Keyword cCommaKeyword_5_3_0 = (Keyword)cGroup_5_3.eContents().get(0);
		private final Assignment cActionsAssignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cActionsStepParserRuleCall_5_3_1_0 = (RuleCall)cActionsAssignment_5_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_4 = (Keyword)cGroup_5.eContents().get(4);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// a scene bundles objects and contains steps to escape to a new scene
		//Scene:
		//	'scene' name=ID ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
		//	'description' description=STRING ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'scene' name=ID ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')? 'description' description=STRING
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')? 'end'
		public Group getGroup() { return cGroup; }
		
		//'scene'
		public Keyword getSceneKeyword_0() { return cSceneKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'objects'
		public Keyword getObjectsKeyword_2_0() { return cObjectsKeyword_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_1() { return cLeftParenthesisKeyword_2_1; }
		
		//objects+=[Object]
		public Assignment getObjectsAssignment_2_2() { return cObjectsAssignment_2_2; }
		
		//[Object]
		public CrossReference getObjectsObjectCrossReference_2_2_0() { return cObjectsObjectCrossReference_2_2_0; }
		
		//ID
		public RuleCall getObjectsObjectIDTerminalRuleCall_2_2_0_1() { return cObjectsObjectIDTerminalRuleCall_2_2_0_1; }
		
		//(',' objects+=[Object])*
		public Group getGroup_2_3() { return cGroup_2_3; }
		
		//','
		public Keyword getCommaKeyword_2_3_0() { return cCommaKeyword_2_3_0; }
		
		//objects+=[Object]
		public Assignment getObjectsAssignment_2_3_1() { return cObjectsAssignment_2_3_1; }
		
		//[Object]
		public CrossReference getObjectsObjectCrossReference_2_3_1_0() { return cObjectsObjectCrossReference_2_3_1_0; }
		
		//ID
		public RuleCall getObjectsObjectIDTerminalRuleCall_2_3_1_0_1() { return cObjectsObjectIDTerminalRuleCall_2_3_1_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_4() { return cRightParenthesisKeyword_2_4; }
		
		//'description'
		public Keyword getDescriptionKeyword_3() { return cDescriptionKeyword_3; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_4_0() { return cDescriptionSTRINGTerminalRuleCall_4_0; }
		
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'actions'
		public Keyword getActionsKeyword_5_0() { return cActionsKeyword_5_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5_1() { return cLeftParenthesisKeyword_5_1; }
		
		//actions+=Step
		public Assignment getActionsAssignment_5_2() { return cActionsAssignment_5_2; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_5_2_0() { return cActionsStepParserRuleCall_5_2_0; }
		
		//(',' actions+=Step)*
		public Group getGroup_5_3() { return cGroup_5_3; }
		
		//','
		public Keyword getCommaKeyword_5_3_0() { return cCommaKeyword_5_3_0; }
		
		//actions+=Step
		public Assignment getActionsAssignment_5_3_1() { return cActionsAssignment_5_3_1; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_5_3_1_0() { return cActionsStepParserRuleCall_5_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5_4() { return cRightParenthesisKeyword_5_4; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Object");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cObjectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cExtendsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cSuperTypeObjectCrossReference_2_1_0 = (CrossReference)cSuperTypeAssignment_2_1.eContents().get(0);
		private final RuleCall cSuperTypeObjectIDTerminalRuleCall_2_1_0_1 = (RuleCall)cSuperTypeObjectCrossReference_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cDescriptionKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDescriptionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_5_0 = (RuleCall)cDescriptionAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// objects are registered with a scene, e.g. "bomb", "mushroom", ...
		//Object:
		//	'object' name=(STRING | ID) ('extends' superType=[Object])? '{'
		//	'description' description=STRING
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'object' name=(STRING | ID) ('extends' superType=[Object])? '{' 'description' description=STRING 'end'
		public Group getGroup() { return cGroup; }
		
		//'object'
		public Keyword getObjectKeyword_0() { return cObjectKeyword_0; }
		
		//name=(STRING | ID)
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(STRING | ID)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_0() { return cNameSTRINGTerminalRuleCall_1_0_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_1() { return cNameIDTerminalRuleCall_1_0_1; }
		
		//('extends' superType=[Object])?
		public Group getGroup_2() { return cGroup_2; }
		
		//'extends'
		public Keyword getExtendsKeyword_2_0() { return cExtendsKeyword_2_0; }
		
		//superType=[Object]
		public Assignment getSuperTypeAssignment_2_1() { return cSuperTypeAssignment_2_1; }
		
		//[Object]
		public CrossReference getSuperTypeObjectCrossReference_2_1_0() { return cSuperTypeObjectCrossReference_2_1_0; }
		
		//ID
		public RuleCall getSuperTypeObjectIDTerminalRuleCall_2_1_0_1() { return cSuperTypeObjectIDTerminalRuleCall_2_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'description'
		public Keyword getDescriptionKeyword_4() { return cDescriptionKeyword_4; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_5() { return cDescriptionAssignment_5; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_5_0() { return cDescriptionSTRINGTerminalRuleCall_5_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class StepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Step");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActionActionEnumRuleCall_0_0 = (RuleCall)cActionAssignment_0.eContents().get(0);
		private final Assignment cTargetObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTargetObjectObjectCrossReference_1_0 = (CrossReference)cTargetObjectAssignment_1.eContents().get(0);
		private final RuleCall cTargetObjectObjectIDTerminalRuleCall_1_0_1 = (RuleCall)cTargetObjectObjectCrossReference_1_0.eContents().get(1);
		private final Keyword cIfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cValidKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValidAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValidSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cValidAssignment_3_1.eContents().get(0);
		private final Keyword cThenKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cSceneAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cSceneSceneCrossReference_5_0 = (CrossReference)cSceneAssignment_5.eContents().get(0);
		private final RuleCall cSceneSceneIDTerminalRuleCall_5_0_1 = (RuleCall)cSceneSceneCrossReference_5_0.eContents().get(1);
		
		//Step:
		//	action=Action targetObject=[Object] 'if' ('valid' valid=STRING) // some message if the action was valid
		//	'then' scene=[Scene];
		@Override public ParserRule getRule() { return rule; }
		
		//// a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
		//action=Action targetObject=[Object] 'if' ('valid' valid=STRING) // some message if the action was valid
		//'then' scene=[Scene]
		public Group getGroup() { return cGroup; }
		
		//// a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
		//action=Action
		public Assignment getActionAssignment_0() { return cActionAssignment_0; }
		
		//Action
		public RuleCall getActionActionEnumRuleCall_0_0() { return cActionActionEnumRuleCall_0_0; }
		
		//targetObject=[Object]
		public Assignment getTargetObjectAssignment_1() { return cTargetObjectAssignment_1; }
		
		//[Object]
		public CrossReference getTargetObjectObjectCrossReference_1_0() { return cTargetObjectObjectCrossReference_1_0; }
		
		//ID
		public RuleCall getTargetObjectObjectIDTerminalRuleCall_1_0_1() { return cTargetObjectObjectIDTerminalRuleCall_1_0_1; }
		
		//'if'
		public Keyword getIfKeyword_2() { return cIfKeyword_2; }
		
		//'valid' valid=STRING
		public Group getGroup_3() { return cGroup_3; }
		
		//'valid'
		public Keyword getValidKeyword_3_0() { return cValidKeyword_3_0; }
		
		//valid=STRING
		public Assignment getValidAssignment_3_1() { return cValidAssignment_3_1; }
		
		//STRING
		public RuleCall getValidSTRINGTerminalRuleCall_3_1_0() { return cValidSTRINGTerminalRuleCall_3_1_0; }
		
		//// some message if the action was valid
		//'then'
		public Keyword getThenKeyword_4() { return cThenKeyword_4; }
		
		//scene=[Scene]
		public Assignment getSceneAssignment_5() { return cSceneAssignment_5; }
		
		//[Scene]
		public CrossReference getSceneSceneCrossReference_5_0() { return cSceneSceneCrossReference_5_0; }
		
		//ID
		public RuleCall getSceneSceneIDTerminalRuleCall_5_0_1() { return cSceneSceneIDTerminalRuleCall_5_0_1; }
	}
	
	public class ActionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Action");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cJUMPEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cJUMPJumpOverKeyword_0_0 = (Keyword)cJUMPEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPICKEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPICKPickUpKeyword_1_0 = (Keyword)cPICKEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cWALKEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cWALKWalkThroughKeyword_2_0 = (Keyword)cWALKEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cATTACKEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cATTACKAttackKeyword_3_0 = (Keyword)cATTACKEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Action:
		//	JUMP='jump over' | PICK='pick up' | WALK='walk through' | ATTACK='attack' // | ...
		//;
		public EnumRule getRule() { return rule; }
		
		//JUMP='jump over' | PICK='pick up' | WALK='walk through' | ATTACK='attack'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//JUMP='jump over'
		public EnumLiteralDeclaration getJUMPEnumLiteralDeclaration_0() { return cJUMPEnumLiteralDeclaration_0; }
		
		//'jump over'
		public Keyword getJUMPJumpOverKeyword_0_0() { return cJUMPJumpOverKeyword_0_0; }
		
		//PICK='pick up'
		public EnumLiteralDeclaration getPICKEnumLiteralDeclaration_1() { return cPICKEnumLiteralDeclaration_1; }
		
		//'pick up'
		public Keyword getPICKPickUpKeyword_1_0() { return cPICKPickUpKeyword_1_0; }
		
		//WALK='walk through'
		public EnumLiteralDeclaration getWALKEnumLiteralDeclaration_2() { return cWALKEnumLiteralDeclaration_2; }
		
		//'walk through'
		public Keyword getWALKWalkThroughKeyword_2_0() { return cWALKWalkThroughKeyword_2_0; }
		
		//ATTACK='attack'
		public EnumLiteralDeclaration getATTACKEnumLiteralDeclaration_3() { return cATTACKEnumLiteralDeclaration_3; }
		
		//'attack'
		public Keyword getATTACKAttackKeyword_3_0() { return cATTACKAttackKeyword_3_0; }
	}
	
	private final AdventureElements pAdventure;
	private final IngredientElements pIngredient;
	private final HeroElements pHero;
	private final SceneElements pScene;
	private final ObjectElements pObject;
	private final StepElements pStep;
	private final ActionElements eAction;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GameGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAdventure = new AdventureElements();
		this.pIngredient = new IngredientElements();
		this.pHero = new HeroElements();
		this.pScene = new SceneElements();
		this.pObject = new ObjectElements();
		this.pStep = new StepElements();
		this.eAction = new ActionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("uibk.dsl.assignment3.Game".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///* HOWTO implement a code generator for text-based adventure, a suggestion ...
	// * Alternative 1
	// * 1) for each Scene generate a Java-class printing its description and all its objects on construction
	// * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
	// * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
	// * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
	// * 		(a new one or "this", in case we stayed at the same scene)
	// * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
	// * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
	// *
	// * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
	// * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
	// * here that you find useful for your own adventure game definition.
	// */ // the actual game
	//Adventure:
	//	'start' startScene=[Scene] & 'end' endScene=[Scene] & ingredients+=Ingredient*;
	public AdventureElements getAdventureAccess() {
		return pAdventure;
	}
	
	public ParserRule getAdventureRule() {
		return getAdventureAccess().getRule();
	}
	
	//// what the adventure is composed of
	//Ingredient:
	//	Scene | Object | Hero;
	public IngredientElements getIngredientAccess() {
		return pIngredient;
	}
	
	public ParserRule getIngredientRule() {
		return getIngredientAccess().getRule();
	}
	
	//Hero:
	//	'name' name=ID
	//	'HP' healthPoints=STRING;
	public HeroElements getHeroAccess() {
		return pHero;
	}
	
	public ParserRule getHeroRule() {
		return getHeroAccess().getRule();
	}
	
	//// a scene bundles objects and contains steps to escape to a new scene
	//Scene:
	//	'scene' name=ID ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
	//	'description' description=STRING ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
	//	'end';
	public SceneElements getSceneAccess() {
		return pScene;
	}
	
	public ParserRule getSceneRule() {
		return getSceneAccess().getRule();
	}
	
	//// objects are registered with a scene, e.g. "bomb", "mushroom", ...
	//Object:
	//	'object' name=(STRING | ID) ('extends' superType=[Object])? '{'
	//	'description' description=STRING
	//	'end';
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	//Step:
	//	action=Action targetObject=[Object] 'if' ('valid' valid=STRING) // some message if the action was valid
	//	'then' scene=[Scene];
	public StepElements getStepAccess() {
		return pStep;
	}
	
	public ParserRule getStepRule() {
		return getStepAccess().getRule();
	}
	
	//enum Action:
	//	JUMP='jump over' | PICK='pick up' | WALK='walk through' | ATTACK='attack' // | ...
	//;
	public ActionElements getActionAccess() {
		return eAction;
	}
	
	public EnumRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
