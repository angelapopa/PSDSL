grammar uibk.dsl.assignment3.Game with org.eclipse.xtext.common.Terminals

generate game "http://www.dsl.uibk/assignment3/Game"

DomainModel:
	Adventure | DataType
;

Adventure:
	'game' name=QualifiedName
	//('start' startScene = [Scene]) & // where to start
	//('end' endScene = [Scene]) & // when it's over
	(ingredients += Ingredient)* 
	'mainClass' mainclass = Class
	('mainFucntion' mainfunction = [Function])?
;

QualifiedName:
    ID ('.' ID)*;
    
DataType:
	'datatype' name=ID
;

Class:
	'class' name=ID ('implements' superType=[Class])? '{'
	('constructor' '{'
		(firstcall += [Function])*
	 '}')?
	 (properties += Property)*
	 (nestedClass += Class)*
	 (functions += Function)*
	 '}'
;

Function:
	'function' name=ID '{'
		
	'}'
;

Property:
	name=ID ('is' 'list' 'of')? ('is' 'list' 'iterator' 'of')? type=DataType | Ingredient
;

// what the adventure is composed of
Ingredient:
	Scene | Object | Character
;

// a scene bundles objects and contains steps to escape to a new scene
Scene:
	'scene' name = ID '{'
	('objects' '(' objects += [Object] (',' objects += [Object])* ')')?
	//'description' description = STRING
	('actions' '(' actions += Step (',' actions += Step)* ')')?
	'}'
;

AttributeType: STRING | INT;

Attribute:
	name=ID value=AttributeType
;

Character:
	'character' name = (STRING | ID) '{'
	attributes += Attribute*
	('actions' '(' actions += Action (',' actions += Action)* ')')?
	'}'
;

// objects are registered with a scene, e.g. "bomb", "mushroom", ...
Object:
	'object' name = (STRING | ID) ('is' 'a' superType=[Object])? '{'
	attributes += Attribute*
	('actions' '(' actions += Action (',' actions += Action)* ')')?
	'}'
;

//TODO: currently not used
Step:
	'step' '{'
	// a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
	action = Action targetObject = [Object] 'if'
		('valid' valid = STRING) // some message if the action was valid
		'then' scene = [Scene] // if the encountered action is valid, open a new scene, e.g., when going through a door
		// if you want to have multiple actions within a single scene you probably need further create internal state tracking within scenes
	'}'
;

// arbitrary actions to be used in the game
// in case they are more complex (e.g., have more parameters) you might consider rewriting them to parser rules
enum Action:
	JUMP = 'jump over' | PICK = 'pick up' | WALK = 'walk through' | ATTACK = 'attack' // | ...
;
