/*
 * generated by Xtext 2.12.0
 */
package uibk.dsl.assignment3.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GameGrammarAccess extends AbstractGrammarElementFinder {
	
	public class AdventureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Adventure");
		private final Assignment cIngredientsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIngredientsIngredientParserRuleCall_0 = (RuleCall)cIngredientsAssignment.eContents().get(0);
		
		///* HOWTO implement a code generator for text-based adventure, a suggestion ...
		// * Alternative 1
		// * 1) for each Scene generate a Java-class printing its description and all its objects on construction
		// * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
		// * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
		// * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
		// * 		(a new one or "this", in case we stayed at the same scene)
		// * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
		// * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
		// *
		// * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
		// * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
		// * here that you find useful for your own adventure game definition.
		// */ // the actual game
		//Adventure:
		//	ingredients+=Ingredient*;
		@Override public ParserRule getRule() { return rule; }
		
		////('start' startScene = [Scene]) & // where to start
		////('end' endScene = [Scene]) & // when it's over
		//ingredients+=Ingredient*
		public Assignment getIngredientsAssignment() { return cIngredientsAssignment; }
		
		//Ingredient
		public RuleCall getIngredientsIngredientParserRuleCall_0() { return cIngredientsIngredientParserRuleCall_0; }
	}
	public class IngredientElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Ingredient");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSceneParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCharacterParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// what the adventure is composed of
		//Ingredient:
		//	Scene | Object | Character;
		@Override public ParserRule getRule() { return rule; }
		
		//Scene | Object | Character
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Scene
		public RuleCall getSceneParserRuleCall_0() { return cSceneParserRuleCall_0; }
		
		//Object
		public RuleCall getObjectParserRuleCall_1() { return cObjectParserRuleCall_1; }
		
		//Character
		public RuleCall getCharacterParserRuleCall_2() { return cCharacterParserRuleCall_2; }
	}
	public class SceneElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Scene");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSceneKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cObjectsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cObjectsAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final CrossReference cObjectsObjectCrossReference_3_2_0 = (CrossReference)cObjectsAssignment_3_2.eContents().get(0);
		private final RuleCall cObjectsObjectIDTerminalRuleCall_3_2_0_1 = (RuleCall)cObjectsObjectCrossReference_3_2_0.eContents().get(1);
		private final Group cGroup_3_3 = (Group)cGroup_3.eContents().get(3);
		private final Keyword cCommaKeyword_3_3_0 = (Keyword)cGroup_3_3.eContents().get(0);
		private final Assignment cObjectsAssignment_3_3_1 = (Assignment)cGroup_3_3.eContents().get(1);
		private final CrossReference cObjectsObjectCrossReference_3_3_1_0 = (CrossReference)cObjectsAssignment_3_3_1.eContents().get(0);
		private final RuleCall cObjectsObjectIDTerminalRuleCall_3_3_1_0_1 = (RuleCall)cObjectsObjectCrossReference_3_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_4 = (Keyword)cGroup_3.eContents().get(4);
		private final Keyword cDescriptionKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDescriptionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_5_0 = (RuleCall)cDescriptionAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cActionsKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cActionsAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cActionsStepParserRuleCall_6_2_0 = (RuleCall)cActionsAssignment_6_2.eContents().get(0);
		private final Group cGroup_6_3 = (Group)cGroup_6.eContents().get(3);
		private final Keyword cCommaKeyword_6_3_0 = (Keyword)cGroup_6_3.eContents().get(0);
		private final Assignment cActionsAssignment_6_3_1 = (Assignment)cGroup_6_3.eContents().get(1);
		private final RuleCall cActionsStepParserRuleCall_6_3_1_0 = (RuleCall)cActionsAssignment_6_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6_4 = (Keyword)cGroup_6.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// a scene bundles objects and contains steps to escape to a new scene
		//Scene:
		//	'scene' name=ID '{' ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
		//	'description' description=STRING ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'scene' name=ID '{' ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')? 'description' description=STRING
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')? '}'
		public Group getGroup() { return cGroup; }
		
		//'scene'
		public Keyword getSceneKeyword_0() { return cSceneKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
		public Group getGroup_3() { return cGroup_3; }
		
		//'objects'
		public Keyword getObjectsKeyword_3_0() { return cObjectsKeyword_3_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_1() { return cLeftParenthesisKeyword_3_1; }
		
		//objects+=[Object]
		public Assignment getObjectsAssignment_3_2() { return cObjectsAssignment_3_2; }
		
		//[Object]
		public CrossReference getObjectsObjectCrossReference_3_2_0() { return cObjectsObjectCrossReference_3_2_0; }
		
		//ID
		public RuleCall getObjectsObjectIDTerminalRuleCall_3_2_0_1() { return cObjectsObjectIDTerminalRuleCall_3_2_0_1; }
		
		//(',' objects+=[Object])*
		public Group getGroup_3_3() { return cGroup_3_3; }
		
		//','
		public Keyword getCommaKeyword_3_3_0() { return cCommaKeyword_3_3_0; }
		
		//objects+=[Object]
		public Assignment getObjectsAssignment_3_3_1() { return cObjectsAssignment_3_3_1; }
		
		//[Object]
		public CrossReference getObjectsObjectCrossReference_3_3_1_0() { return cObjectsObjectCrossReference_3_3_1_0; }
		
		//ID
		public RuleCall getObjectsObjectIDTerminalRuleCall_3_3_1_0_1() { return cObjectsObjectIDTerminalRuleCall_3_3_1_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_4() { return cRightParenthesisKeyword_3_4; }
		
		//'description'
		public Keyword getDescriptionKeyword_4() { return cDescriptionKeyword_4; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_5() { return cDescriptionAssignment_5; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_5_0() { return cDescriptionSTRINGTerminalRuleCall_5_0; }
		
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		public Group getGroup_6() { return cGroup_6; }
		
		//'actions'
		public Keyword getActionsKeyword_6_0() { return cActionsKeyword_6_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6_1() { return cLeftParenthesisKeyword_6_1; }
		
		//actions+=Step
		public Assignment getActionsAssignment_6_2() { return cActionsAssignment_6_2; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_6_2_0() { return cActionsStepParserRuleCall_6_2_0; }
		
		//(',' actions+=Step)*
		public Group getGroup_6_3() { return cGroup_6_3; }
		
		//','
		public Keyword getCommaKeyword_6_3_0() { return cCommaKeyword_6_3_0; }
		
		//actions+=Step
		public Assignment getActionsAssignment_6_3_1() { return cActionsAssignment_6_3_1; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_6_3_1_0() { return cActionsStepParserRuleCall_6_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6_4() { return cRightParenthesisKeyword_6_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class CharacterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Character");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCharacterKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cDescriptionKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		private final Keyword cHealthPointsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cHealthPointsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cHealthPointsINTTerminalRuleCall_6_0 = (RuleCall)cHealthPointsAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cActionsKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Assignment cActionsAssignment_7_2 = (Assignment)cGroup_7.eContents().get(2);
		private final RuleCall cActionsStepParserRuleCall_7_2_0 = (RuleCall)cActionsAssignment_7_2.eContents().get(0);
		private final Group cGroup_7_3 = (Group)cGroup_7.eContents().get(3);
		private final Keyword cCommaKeyword_7_3_0 = (Keyword)cGroup_7_3.eContents().get(0);
		private final Assignment cActionsAssignment_7_3_1 = (Assignment)cGroup_7_3.eContents().get(1);
		private final RuleCall cActionsStepParserRuleCall_7_3_1_0 = (RuleCall)cActionsAssignment_7_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7_4 = (Keyword)cGroup_7.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Character:
		//	'character' name=(STRING | ID) '{'
		//	'description' description=STRING
		//	'healthPoints' healthPoints=INT ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'character' name=(STRING | ID) '{' 'description' description=STRING 'healthPoints' healthPoints=INT ('actions' '('
		//actions+=Step (',' actions+=Step)* ')')? '}'
		public Group getGroup() { return cGroup; }
		
		//'character'
		public Keyword getCharacterKeyword_0() { return cCharacterKeyword_0; }
		
		//name=(STRING | ID)
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(STRING | ID)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_0() { return cNameSTRINGTerminalRuleCall_1_0_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_1() { return cNameIDTerminalRuleCall_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//'description'
		public Keyword getDescriptionKeyword_3() { return cDescriptionKeyword_3; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_4_0() { return cDescriptionSTRINGTerminalRuleCall_4_0; }
		
		//'healthPoints'
		public Keyword getHealthPointsKeyword_5() { return cHealthPointsKeyword_5; }
		
		//healthPoints=INT
		public Assignment getHealthPointsAssignment_6() { return cHealthPointsAssignment_6; }
		
		//INT
		public RuleCall getHealthPointsINTTerminalRuleCall_6_0() { return cHealthPointsINTTerminalRuleCall_6_0; }
		
		//('actions' '(' actions+=Step (',' actions+=Step)* ')')?
		public Group getGroup_7() { return cGroup_7; }
		
		//'actions'
		public Keyword getActionsKeyword_7_0() { return cActionsKeyword_7_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_1() { return cLeftParenthesisKeyword_7_1; }
		
		//actions+=Step
		public Assignment getActionsAssignment_7_2() { return cActionsAssignment_7_2; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_7_2_0() { return cActionsStepParserRuleCall_7_2_0; }
		
		//(',' actions+=Step)*
		public Group getGroup_7_3() { return cGroup_7_3; }
		
		//','
		public Keyword getCommaKeyword_7_3_0() { return cCommaKeyword_7_3_0; }
		
		//actions+=Step
		public Assignment getActionsAssignment_7_3_1() { return cActionsAssignment_7_3_1; }
		
		//Step
		public RuleCall getActionsStepParserRuleCall_7_3_1_0() { return cActionsStepParserRuleCall_7_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_4() { return cRightParenthesisKeyword_7_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Object");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cObjectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cIsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cAKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cSuperTypeAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final CrossReference cSuperTypeObjectCrossReference_2_2_0 = (CrossReference)cSuperTypeAssignment_2_2.eContents().get(0);
		private final RuleCall cSuperTypeObjectIDTerminalRuleCall_2_2_0_1 = (RuleCall)cSuperTypeObjectCrossReference_2_2_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cDescriptionKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDescriptionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_5_0 = (RuleCall)cDescriptionAssignment_5.eContents().get(0);
		private final Keyword cHealthPointsKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cHealthPointsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cHealthPointsINTTerminalRuleCall_7_0 = (RuleCall)cHealthPointsAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cActionsKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cActionsAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cActionsActionEnumRuleCall_8_2_0 = (RuleCall)cActionsAssignment_8_2.eContents().get(0);
		private final Group cGroup_8_3 = (Group)cGroup_8.eContents().get(3);
		private final Keyword cCommaKeyword_8_3_0 = (Keyword)cGroup_8_3.eContents().get(0);
		private final Assignment cActionsAssignment_8_3_1 = (Assignment)cGroup_8_3.eContents().get(1);
		private final RuleCall cActionsActionEnumRuleCall_8_3_1_0 = (RuleCall)cActionsAssignment_8_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_4 = (Keyword)cGroup_8.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//// objects are registered with a scene, e.g. "bomb", "mushroom", ...
		//Object:
		//	'object' name=(STRING | ID) ('is' 'a' superType=[Object])? '{'
		//	'description' description=STRING
		//	'healthPoints' healthPoints=INT ('actions' '(' actions+=Action (',' actions+=Action)* ')')?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'object' name=(STRING | ID) ('is' 'a' superType=[Object])? '{' 'description' description=STRING 'healthPoints'
		//healthPoints=INT ('actions' '(' actions+=Action (',' actions+=Action)* ')')? '}'
		public Group getGroup() { return cGroup; }
		
		//'object'
		public Keyword getObjectKeyword_0() { return cObjectKeyword_0; }
		
		//name=(STRING | ID)
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(STRING | ID)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0_0() { return cNameSTRINGTerminalRuleCall_1_0_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_1() { return cNameIDTerminalRuleCall_1_0_1; }
		
		//('is' 'a' superType=[Object])?
		public Group getGroup_2() { return cGroup_2; }
		
		//'is'
		public Keyword getIsKeyword_2_0() { return cIsKeyword_2_0; }
		
		//'a'
		public Keyword getAKeyword_2_1() { return cAKeyword_2_1; }
		
		//superType=[Object]
		public Assignment getSuperTypeAssignment_2_2() { return cSuperTypeAssignment_2_2; }
		
		//[Object]
		public CrossReference getSuperTypeObjectCrossReference_2_2_0() { return cSuperTypeObjectCrossReference_2_2_0; }
		
		//ID
		public RuleCall getSuperTypeObjectIDTerminalRuleCall_2_2_0_1() { return cSuperTypeObjectIDTerminalRuleCall_2_2_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'description'
		public Keyword getDescriptionKeyword_4() { return cDescriptionKeyword_4; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_5() { return cDescriptionAssignment_5; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_5_0() { return cDescriptionSTRINGTerminalRuleCall_5_0; }
		
		//'healthPoints'
		public Keyword getHealthPointsKeyword_6() { return cHealthPointsKeyword_6; }
		
		//healthPoints=INT
		public Assignment getHealthPointsAssignment_7() { return cHealthPointsAssignment_7; }
		
		//INT
		public RuleCall getHealthPointsINTTerminalRuleCall_7_0() { return cHealthPointsINTTerminalRuleCall_7_0; }
		
		//('actions' '(' actions+=Action (',' actions+=Action)* ')')?
		public Group getGroup_8() { return cGroup_8; }
		
		//'actions'
		public Keyword getActionsKeyword_8_0() { return cActionsKeyword_8_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_8_1() { return cLeftParenthesisKeyword_8_1; }
		
		//actions+=Action
		public Assignment getActionsAssignment_8_2() { return cActionsAssignment_8_2; }
		
		//Action
		public RuleCall getActionsActionEnumRuleCall_8_2_0() { return cActionsActionEnumRuleCall_8_2_0; }
		
		//(',' actions+=Action)*
		public Group getGroup_8_3() { return cGroup_8_3; }
		
		//','
		public Keyword getCommaKeyword_8_3_0() { return cCommaKeyword_8_3_0; }
		
		//actions+=Action
		public Assignment getActionsAssignment_8_3_1() { return cActionsAssignment_8_3_1; }
		
		//Action
		public RuleCall getActionsActionEnumRuleCall_8_3_1_0() { return cActionsActionEnumRuleCall_8_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8_4() { return cRightParenthesisKeyword_8_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class StepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Step");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStepKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActionActionEnumRuleCall_2_0 = (RuleCall)cActionAssignment_2.eContents().get(0);
		private final Assignment cTargetObjectAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTargetObjectObjectCrossReference_3_0 = (CrossReference)cTargetObjectAssignment_3.eContents().get(0);
		private final RuleCall cTargetObjectObjectIDTerminalRuleCall_3_0_1 = (RuleCall)cTargetObjectObjectCrossReference_3_0.eContents().get(1);
		private final Keyword cIfKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cValidKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cValidAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cValidSTRINGTerminalRuleCall_5_1_0 = (RuleCall)cValidAssignment_5_1.eContents().get(0);
		private final Keyword cThenKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cSceneAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cSceneSceneCrossReference_7_0 = (CrossReference)cSceneAssignment_7.eContents().get(0);
		private final RuleCall cSceneSceneIDTerminalRuleCall_7_0_1 = (RuleCall)cSceneSceneCrossReference_7_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Step:
		//	'step' '{'
		//	// a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
		//	action=Action targetObject=[Object] 'if' ('valid' valid=STRING) // some message if the action was valid
		//	'then' scene=[Scene] // if the encountered action is valid, open a new scene, e.g., when going through a door
		//	// if you want to have multiple actions within a single scene you probably need further create internal state tracking within scenes
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'step' '{' // a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
		//action=Action targetObject=[Object] 'if' ('valid' valid=STRING) // some message if the action was valid
		//'then' scene=[Scene] // if the encountered action is valid, open a new scene, e.g., when going through a door
		//// if you want to have multiple actions within a single scene you probably need further create internal state tracking within scenes
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'step'
		public Keyword getStepKeyword_0() { return cStepKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//// a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
		//action=Action
		public Assignment getActionAssignment_2() { return cActionAssignment_2; }
		
		//Action
		public RuleCall getActionActionEnumRuleCall_2_0() { return cActionActionEnumRuleCall_2_0; }
		
		//targetObject=[Object]
		public Assignment getTargetObjectAssignment_3() { return cTargetObjectAssignment_3; }
		
		//[Object]
		public CrossReference getTargetObjectObjectCrossReference_3_0() { return cTargetObjectObjectCrossReference_3_0; }
		
		//ID
		public RuleCall getTargetObjectObjectIDTerminalRuleCall_3_0_1() { return cTargetObjectObjectIDTerminalRuleCall_3_0_1; }
		
		//'if'
		public Keyword getIfKeyword_4() { return cIfKeyword_4; }
		
		//'valid' valid=STRING
		public Group getGroup_5() { return cGroup_5; }
		
		//'valid'
		public Keyword getValidKeyword_5_0() { return cValidKeyword_5_0; }
		
		//valid=STRING
		public Assignment getValidAssignment_5_1() { return cValidAssignment_5_1; }
		
		//STRING
		public RuleCall getValidSTRINGTerminalRuleCall_5_1_0() { return cValidSTRINGTerminalRuleCall_5_1_0; }
		
		//// some message if the action was valid
		//'then'
		public Keyword getThenKeyword_6() { return cThenKeyword_6; }
		
		//scene=[Scene]
		public Assignment getSceneAssignment_7() { return cSceneAssignment_7; }
		
		//[Scene]
		public CrossReference getSceneSceneCrossReference_7_0() { return cSceneSceneCrossReference_7_0; }
		
		//ID
		public RuleCall getSceneSceneIDTerminalRuleCall_7_0_1() { return cSceneSceneIDTerminalRuleCall_7_0_1; }
		
		//// if the encountered action is valid, open a new scene, e.g., when going through a door
		//// if you want to have multiple actions within a single scene you probably need further create internal state tracking within scenes
		//'}'
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}
	
	public class ActionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "uibk.dsl.assignment3.Game.Action");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cJUMPEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cJUMPJumpOverKeyword_0_0 = (Keyword)cJUMPEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPICKEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPICKPickUpKeyword_1_0 = (Keyword)cPICKEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cWALKEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cWALKWalkThroughKeyword_2_0 = (Keyword)cWALKEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cATTACKEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cATTACKAttackKeyword_3_0 = (Keyword)cATTACKEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Action:
		//	JUMP='jump over' | PICK='pick up' | WALK='walk through' | ATTACK='attack' // | ...
		//;
		public EnumRule getRule() { return rule; }
		
		//JUMP='jump over' | PICK='pick up' | WALK='walk through' | ATTACK='attack'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//JUMP='jump over'
		public EnumLiteralDeclaration getJUMPEnumLiteralDeclaration_0() { return cJUMPEnumLiteralDeclaration_0; }
		
		//'jump over'
		public Keyword getJUMPJumpOverKeyword_0_0() { return cJUMPJumpOverKeyword_0_0; }
		
		//PICK='pick up'
		public EnumLiteralDeclaration getPICKEnumLiteralDeclaration_1() { return cPICKEnumLiteralDeclaration_1; }
		
		//'pick up'
		public Keyword getPICKPickUpKeyword_1_0() { return cPICKPickUpKeyword_1_0; }
		
		//WALK='walk through'
		public EnumLiteralDeclaration getWALKEnumLiteralDeclaration_2() { return cWALKEnumLiteralDeclaration_2; }
		
		//'walk through'
		public Keyword getWALKWalkThroughKeyword_2_0() { return cWALKWalkThroughKeyword_2_0; }
		
		//ATTACK='attack'
		public EnumLiteralDeclaration getATTACKEnumLiteralDeclaration_3() { return cATTACKEnumLiteralDeclaration_3; }
		
		//'attack'
		public Keyword getATTACKAttackKeyword_3_0() { return cATTACKAttackKeyword_3_0; }
	}
	
	private final AdventureElements pAdventure;
	private final IngredientElements pIngredient;
	private final SceneElements pScene;
	private final CharacterElements pCharacter;
	private final ObjectElements pObject;
	private final StepElements pStep;
	private final ActionElements eAction;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GameGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAdventure = new AdventureElements();
		this.pIngredient = new IngredientElements();
		this.pScene = new SceneElements();
		this.pCharacter = new CharacterElements();
		this.pObject = new ObjectElements();
		this.pStep = new StepElements();
		this.eAction = new ActionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("uibk.dsl.assignment3.Game".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///* HOWTO implement a code generator for text-based adventure, a suggestion ...
	// * Alternative 1
	// * 1) for each Scene generate a Java-class printing its description and all its objects on construction
	// * 2) for each Object generate a Java-class overriding the "toString"-method with the objects description
	// * 3) create an AbstractScene class which forces a Scene to implement a method for performing a step,
	// * 		e.g., "Scene performStep(Action, Object, Preposition, Object)" - taking a step and returning a Scene 
	// * 		(a new one or "this", in case we stayed at the same scene)
	// * 4) a Scene's performStep prints the "valid" or "default" (i.e. invalid) message
	// * 5) evaluate valid or invalid according to an internal step counter, which is incremented on a valid step
	// *
	// * NOTE: The following DSL should be understood to guide you through defining your own grammar. Don't let
	// * yourself be bound to what you see below - be creative! Of course you can still make use of any concept
	// * here that you find useful for your own adventure game definition.
	// */ // the actual game
	//Adventure:
	//	ingredients+=Ingredient*;
	public AdventureElements getAdventureAccess() {
		return pAdventure;
	}
	
	public ParserRule getAdventureRule() {
		return getAdventureAccess().getRule();
	}
	
	//// what the adventure is composed of
	//Ingredient:
	//	Scene | Object | Character;
	public IngredientElements getIngredientAccess() {
		return pIngredient;
	}
	
	public ParserRule getIngredientRule() {
		return getIngredientAccess().getRule();
	}
	
	//// a scene bundles objects and contains steps to escape to a new scene
	//Scene:
	//	'scene' name=ID '{' ('objects' '(' objects+=[Object] (',' objects+=[Object])* ')')?
	//	'description' description=STRING ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
	//	'}';
	public SceneElements getSceneAccess() {
		return pScene;
	}
	
	public ParserRule getSceneRule() {
		return getSceneAccess().getRule();
	}
	
	//Character:
	//	'character' name=(STRING | ID) '{'
	//	'description' description=STRING
	//	'healthPoints' healthPoints=INT ('actions' '(' actions+=Step (',' actions+=Step)* ')')?
	//	'}';
	public CharacterElements getCharacterAccess() {
		return pCharacter;
	}
	
	public ParserRule getCharacterRule() {
		return getCharacterAccess().getRule();
	}
	
	//// objects are registered with a scene, e.g. "bomb", "mushroom", ...
	//Object:
	//	'object' name=(STRING | ID) ('is' 'a' superType=[Object])? '{'
	//	'description' description=STRING
	//	'healthPoints' healthPoints=INT ('actions' '(' actions+=Action (',' actions+=Action)* ')')?
	//	'}';
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	//Step:
	//	'step' '{'
	//	// a step to solve the adventure, e.g., "pick up bomb" or "jump over the hole"	
	//	action=Action targetObject=[Object] 'if' ('valid' valid=STRING) // some message if the action was valid
	//	'then' scene=[Scene] // if the encountered action is valid, open a new scene, e.g., when going through a door
	//	// if you want to have multiple actions within a single scene you probably need further create internal state tracking within scenes
	//	'}';
	public StepElements getStepAccess() {
		return pStep;
	}
	
	public ParserRule getStepRule() {
		return getStepAccess().getRule();
	}
	
	//enum Action:
	//	JUMP='jump over' | PICK='pick up' | WALK='walk through' | ATTACK='attack' // | ...
	//;
	public ActionElements getActionAccess() {
		return eAction;
	}
	
	public EnumRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
